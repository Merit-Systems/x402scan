# yaml-language-server: $schema=https://promptfoo.dev/config-schema.json
description: 'Claude Agent SDK Single-Prompt Evaluation'

# Output results to JSON for full data capture
outputPath: evals/single-prompt-results.json

# Extension to log tool usage details from Claude session logs
extensions:
  - file://extensions/log-tools.js:module.exports

providers:
  - id: anthropic:claude-agent-sdk
    label: 'x402scan MCP + WebTools - Sonnet 4.5'
    config:
      model: claude-sonnet-4-5-20250929
      mcp:
        servers:
          - command: sh
            args: ['-c', 'node ${MCP_SERVER_DIR}/index.js']
            name: x402scan
      include_partial_messages: true
      max_budget_usd: 1.50
      output_format:
        type: json_schema
        schema:
          type: object
          properties:
            answer:
              description: 'The answer to the question'
            sources:
              type: array
              items:
                type: string
              description: 'URLs or references used'
            tool_call_log:
              type: array
              items:
                type: object
                properties:
                  tool:
                    type: string
                  input:
                    type: object
                  success:
                    type: boolean
              description: 'Log of tool calls made'
          required: [answer, tool_call_log]
      append_allowed_tools:
        - 'mcp__x402scan__fetch'
        - 'mcp__x402scan__authed_call'
        - 'mcp__x402scan__check_balance'
        - 'mcp__x402scan__get_wallet_address'
        - 'mcp__x402scan__check_x402_endpoint'
        - 'mcp__x402scan__discover_resources'
        - 'mcp__x402scan__report_error'
        - 'WebFetch'
        - 'WebSearch'

evaluateOptions:
  repeat: 5

# Default test configuration applied to all test cases
defaultTest:
  options:
    provider: anthropic:messages:claude-sonnet-4-5-20250929
  assert:
    # Validate structured output format
    - type: javascript
      value: |
        const isObject = typeof output === 'object' && output !== null;
        const hasAnswer = isObject && 'answer' in output;
        return {
          pass: hasAnswer,
          score: hasAnswer ? 1 : 0,
          reason: hasAnswer ? 'Valid structured output' : 'Missing answer field in output'
        };
      metric: structured_output_valid

    # Track sources provided
    - type: javascript
      value: |
        const sources = output?.sources || [];
        const hasSources = Array.isArray(sources) && sources.length > 0;
        return {
          pass: true,
          score: hasSources ? Math.min(sources.length / 3, 1) : 0,
          reason: hasSources ? `${sources.length} sources provided` : 'No sources provided',
          namedScores: { source_count: sources.length }
        };
      metric: sources_provided

    # Track self-reported tool calls
    - type: javascript
      value: |
        const toolLog = output?.tool_call_log || [];
        const hasToolLog = Array.isArray(toolLog) && toolLog.length > 0;
        const successCount = toolLog.filter(t => t.success).length;
        return {
          pass: true,
          score: hasToolLog ? 1 : 0,
          reason: hasToolLog ? `${toolLog.length} tool calls logged (${successCount} successful)` : 'No tool calls logged',
          namedScores: { 
            reported_tool_calls: toolLog.length,
            reported_successful_calls: successCount
          }
        };
      metric: tool_call_log

# Single prompt that uses a variable - tests define the actual prompt text
prompts:
  - '{{prompt}}'

# Tests with inline prompts - each test has its prompt and specific assertions
tests:
  - description: 'Merit Systems CEO Email'
    vars:
      prompt: 'Find and return the email of the CEO of Merit Systems'
    assert:
      - type: javascript
        value: |
          const answer = output?.answer || '';
          const text = typeof answer === 'string' ? answer : JSON.stringify(answer);
          const emailRegex = /[\w.-]+@[\w.-]+\.\w{2,}/g;
          const emails = text.match(emailRegex) || [];
          return {
            pass: emails.length > 0,
            score: emails.length > 0 ? 1 : 0,
            reason: emails.length > 0 ? `Found email: ${emails[0]}` : 'No valid email found'
          };
        metric: email_found
      - type: javascript
        value: |
          const answer = output?.answer || '';
          const text = typeof answer === 'string' ? answer : JSON.stringify(answer);
          const hasCeoContext = /ceo|chief executive|founder|co-founder|sam/i.test(text);
          return {
            pass: true,
            score: hasCeoContext ? 1 : 0,
            reason: hasCeoContext ? 'Response identifies CEO' : 'Response does not identify CEO'
          };
        metric: ceo_identified
      # Verify email is sam@merit.systems
      - type: javascript
        value: |
          const answer = output?.answer || '';
          const text = typeof answer === 'string' ? answer : JSON.stringify(answer);
          const hasCeoContext = /sam@merit.systems/i.test(text);
          return {
            pass: hasCeoContext,
            score: hasCeoContext ? 1 : 0,
            reason: hasCeoContext ? `Response identifies email sam@merit.systems` : `Response does not identify email sam@merit.systems`
          };
        metric: email_sam_merit_systems
